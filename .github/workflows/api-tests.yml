name: API Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:

jobs:
  api-tests:
    runs-on: ubuntu-latest
    
    services:
      mongodb:
        image: mongo:5.0
        ports:
          - 27017:27017

    steps:
    - name: ðŸ›Žï¸ Checkout code
      uses: actions/checkout@v4
    
    - name: âŽ” Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18.x'
        cache: 'npm'
    
    - name: ðŸ“¦ Install dependencies
      run: npm install
    
    - name: ðŸ”§ Debug:Check server configuration
      run: |
        echo "ðŸ” Analyzing server configuration..."
        # Verificar si index.js exporta una app Express
        if grep -q "module.exports" index.js || grep -q "exports" index.js; then
          echo "âœ… index.js exports something"
        else
          echo "âŒ index.js doesn't seem to export anything"
        fi
        
        # Buscar puertos en el cÃ³digo
        echo "ðŸ“‹ Ports found in code:"
        grep -r "PORT\|port\|3000\|3001" . --include="*.js" | head -10 || echo "No ports found"
        
        # Verificar estructura del index.js
        echo "ðŸ“ index.js structure:"
        head -20 index.js
    
    - name: ðŸ§ª Create test script with better debugging
      run: |
        cat > test-ci.js << 'EOF'
        const http = require('http');
        const net = require('net');
        
        // FunciÃ³n para verificar si un puerto estÃ¡ en uso
        function isPortInUse(port) {
          return new Promise((resolve) => {
            const server = net.createServer();
            server.once('error', () => resolve(true));
            server.once('listening', () => {
              server.close();
              resolve(false);
            });
            server.listen(port);
          });
        }
        
        async function findServerPort() {
          const ports = [3001, 3000, 5000, 8000, 8080];
          console.log('ðŸ” Searching for server port...');
          
          for (const port of ports) {
            if (await isPortInUse(port)) {
              console.log(`âœ… Found server on port ${port}`);
              return port;
            }
          }
          return null;
        }
        
        async function testEndpoint(port, endpoint) {
          return new Promise((resolve, reject) => {
            const req = http.request({
              hostname: 'localhost',
              port: port,
              path: endpoint,
              method: 'GET',
              timeout: 5000
            }, (res) => {
              let data = '';
              res.on('data', chunk => data += chunk);
              res.on('end', () => {
                console.log(`âœ… ${endpoint} - Status: ${res.statusCode}`);
                resolve({ port, status: res.statusCode, data });
              });
            });
            
            req.on('error', (err) => {
              console.log(`âŒ Port ${port}${endpoint} - ${err.message}`);
              reject(err);
            });
            
            req.end();
          });
        }
        
        async function runTests() {
          console.log('ðŸš€ Starting advanced API tests...');
          
          // Buscar en quÃ© puerto estÃ¡ el servidor
          const serverPort = await findServerPort();
          
          if (!serverPort) {
            console.log('ðŸ’€ No server found on common ports');
            return;
          }
          
          console.log(`ðŸŽ¯ Testing server on port ${serverPort}`);
          
          const tests = [
            '/',
            '/api/getUsers',
            '/api/getInventarios'
          ];
          
          for (const test of tests) {
            try {
              await testEndpoint(serverPort, test);
            } catch (err) {
              console.log(`âš ï¸  Skipping ${test} due to error`);
            }
          }
          
          console.log('ðŸŽ‰ Test sequence completed');
        }
        
        runTests().catch(err => {
          console.error('ðŸ’€ Tests failed:', err.message);
          process.exit(1);
        });
        EOF
    
    - name: ðŸš€ Start server with enhanced monitoring
      run: |
        echo "DB_MONGO=mongodb://localhost:27017/test_github" > .env
        echo "PORT=3001" >> .env
        
        echo "ðŸ”§ Starting server with detailed monitoring..."
        
        # Iniciar servidor con logging mejorado
        nohup node -e "
        console.log('ðŸ”„ Starting server initialization...');
        console.log('ðŸ“‹ Process env:', {
          PORT: process.env.PORT,
          DB_MONGO: process.env.DB_MONGO ? 'SET' : 'NOT SET'
        });
        
        try {
          const app = require('./index.js');
          console.log('âœ… Successfully required index.js');
          
          // Si app es una funciÃ³n de Express, iniciarla
          if (typeof app.listen === 'function') {
            const PORT = process.env.PORT || 3001;
            app.listen(PORT, '0.0.0.0', () => {
              console.log('ðŸŽ‰ Server successfully started on port ' + PORT);
              console.log('ðŸ“¡ Listening on 0.0.0.0:' + PORT);
            });
          } else {
            console.log('â„¹ï¸  app.listen not found, assuming server auto-starts');
          }
        } catch (error) {
          console.error('â€ Error requiring index.js:', error.message);
          console.error('ðŸ“œ Stack:', error.stack);
        }
        " > server.log 2>&1 &
        
        SERVER_PID=$!
        echo $SERVER_PID > server.pid
        echo "ðŸ“ Server PID: $SERVER_PID"
        
        # Esperar y monitorear
        echo "â³ Waiting for server with enhanced monitoring..."
        
        for i in {1..40}; do
          # Verificar si el proceso sigue vivo
          if ! ps -p $SERVER_PID > /dev/null; then
            echo "âŒ Server process died!"
            echo "ðŸ“œ Server logs:"
            cat server.log
            exit 1
          fi
          
          # Verificar logs para Ã©xito
          if grep -q "Server successfully started\|Server running\|Listening" server.log; then
            echo "âœ… Server started successfully (found in logs)"
            break
          fi
          
          # Verificar puertos comunes
          for port in 3001 3000 5000 8000 8080; do
            if curl -s http://localhost:$port > /dev/null 2>&1; then
              echo "âœ… Server responding on port $port"
              break 2
            fi
          done
          
          if [ $i -eq 40 ]; then
            echo "âŒ Server not responding after 40 seconds"
            echo "ðŸ“œ Server logs:"
            cat server.log
            echo "ðŸ” Running processes:"
            ps aux | grep node
            echo "ðŸ” Open ports:"
            netstat -tulpn | grep LISTEN
            exit 1
          fi
          
          if [ $i -eq 10 ] || [ $i -eq 20 ] || [ $i -eq 30 ]; then
            echo "ðŸ“‹ Server logs at $i seconds:"
            tail -10 server.log
          fi
          
          echo "â±ï¸ Still waiting... ($i/40)"
          sleep 1
        done
        
        echo "ðŸŽ¯ Server ready for testing"
    
    - name: ðŸ§ª Run smart API tests
      run: |
        echo "ðŸ” Running smart API tests..."
        node test-ci.js
    
    - name: ðŸ“‹ Show comprehensive logs
      if: always()
      run: |
        echo "ðŸ“œ COMPREHENSIVE SERVER LOGS:"
        cat server.log || echo "No server logs"
        
        echo "ðŸ” PROCESS INFO:"
        ps aux | grep node || echo "No node processes"
        
        echo "ðŸŒ NETWORK INFO:"
        netstat -tulpn | grep LISTEN || echo "No listening ports"
        
        echo "ðŸ“Š PORT SCAN:"
        for port in 3000 3001 5000 8000 8080; do
          if curl -s --connect-timeout 2 http://localhost:$port > /dev/null; then
            echo "âœ… Port $port: RESPONDING"
          else
            echo "âŒ Port $port: NOT RESPONDING"
          fi
        done
    
    - name: ðŸ›‘ Cleanup
      if: always()
      run: |
        echo "Cleaning up..."
        if [ -f server.pid ]; then
          kill $(cat server.pid) 2>/dev/null || echo "Process already stopped"
        fi
        # Limpiar procesos de node por si acaso
        pkill -f "node" || echo "No node processes to kill"
